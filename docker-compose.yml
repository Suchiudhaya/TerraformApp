# Terraform + AWS: deploy React frontend + 2 microservices behind NGINX on an EC2 in a custom VPC

This document contains a step‑by‑step guide **and** a complete sample repo layout (Terraform, Docker, NGINX, React, two Node microservices). Use this as a working demo you can adapt to production.

---

## Architecture (simple demo)

```
Internet
   |
   v
 Elastic IP -> EC2 instance (public subnet)
                     |
                 Docker
            ------------------
            |  nginx/proxy    |  <- serves React static + reverse-proxies to
            |  service-a      | -> container:3001
            |  service-b      | -> container:3002
            ------------------
```

All containers run on one EC2 (demo). Terraform creates the VPC, subnet, route table, security group, key pair and an EC2 instance. The EC2 user-data pulls your git repo and runs `docker-compose up -d --build`.

> **Note:** This layout is intended for demonstration / POC. For production, consider ECS/EKS + ALB, separate instances, CI/CD, TLS via ACM, and fine-grained IAM.

---

## What you get in this sample

* Terraform configs that create a VPC (public subnet) + an EC2 instance and security group.
* A `docker-compose.yml` that builds three services: `proxy` (nginx + built React), `service-a` (Node/Express), `service-b` (Node/Express).
* An `nginx` config that proxies `/api/service-a` and `/api/service-b` to the appropriate containers and serves the React `build`.
* Simple example code for both microservices and the React frontend.

---

## Directory layout (suggested)

```
repo-root/
├─ terraform/
│  ├─ main.tf
│  ├─ variables.tf
│  └─ outputs.tf
├─ docker-compose.yml
├─ nginx/
│  ├─ Dockerfile
│  └─ nginx.conf
├─ service-a/
│  ├─ package.json
│  ├─ index.js
│  └─ Dockerfile
├─ service-b/
│  ├─ package.json
│  ├─ index.js
│  └─ Dockerfile
└─ frontend/
   ├─ package.json
   ├─ public/
   └─ src/
       └─ App.js
```

---

## Terraform (core files)

**`terraform/main.tf`**

```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = { source = "hashicorp/aws" }
  }
}

provider "aws" {
  region = var.aws_region
}

data "aws_availability_zones" "available" {}

data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"] # Canonical
  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]
  }
}

resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_support   = true
  enable_dns_hostnames = true
  tags = { Name = "${var.project_name}-vpc" }
}

resource "aws_internet_gateway" "igw" {
  vpc_id = aws_vpc.main.id
  tags   = { Name = "${var.project_name}-igw" }
}

resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.1.0/24"
  map_public_ip_on_launch = true
  availability_zone       = data.aws_availability_zones.available.names[0]
  tags = { Name = "${var.project_name}-public-subnet" }
}

resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.igw.id
  }
  tags = { Name = "${var.project_name}-public-rt" }
}

resource "aws_route_table_association" "a" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public.id
}

resource "aws_security_group" "web" {
  name        = "${var.project_name}-sg"
  description = "Allow SSH/HTTP"
  vpc_id      = aws_vpc.main.id

  ingress {
    description = "SSH from my IP"
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = [var.my_ip_cidr]
  }

  ingress {
    description = "HTTP"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = { Name = "${var.project_name}-sg" }
}

resource "aws_key_pair" "deployer" {
  key_name   = var.key_name
  public_key = file(var.public_key_path)
}

resource "aws_instance" "app" {
  ami                         = data.aws_ami.ubuntu.id
  instance_type               = var.instance_type
  subnet_id                   = aws_subnet.public.id
  associate_public_ip_address = true
  vpc_security_group_ids      = [aws_security_group.web.id]
  key_name                    = aws_key_pair.deployer.key_name

  user_data = <<-EOF
    #!/bin/bash
    set -ex
    apt-get update
    apt-get install -y docker.io git curl
    # install docker-compose (fixed version) - adjust if you prefer Docker Compose v2
    curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    chmod +x /usr/local/bin/docker-compose
    mkdir -p /home/ubuntu/app
    chown ubuntu:ubuntu /home/ubuntu/app
    # clone the repo specified by variable (should be a public https git repo)
    if [ -n "${var.git_repo}" ]; then
      sudo -u ubuntu git clone ${var.git_repo} /home/ubuntu/app || (cd /home/ubuntu/app && sudo -u ubuntu git pull)
    fi
    cd /home/ubuntu/app || exit 0
    /usr/local/bin/docker-compose up -d --build
  EOF

  tags = { Name = "${var.project_name}-instance" }
}

output "instance_public_ip" {
  value = aws_instance.app.public_ip
}
```

**`terraform/variables.tf`**

```hcl
variable "aws_region" { type = string  default = "us-east-1" }
variable "project_name" { type = string default = "demo-app" }
variable "instance_type" { type = string default = "t3.micro" }
variable "key_name" { type = string default = "demo-key" }
variable "public_key_path" { type = string default = "~/.ssh/id_rsa.pub" }
variable "git_repo" { type = string default = "" }
# Restrict SSH to your IP: e.g. "1.2.3.4/32"; default allows everywhere (NOT recommended)
variable "my_ip_cidr" { type = string default = "0.0.0.0/0" }
```

**`terraform/outputs.tf`**

```hcl
output "instance_public_ip" { value = aws_instance.app.public_ip }
```

---

## Docker / app side (important files)

**`docker-compose.yml`** (repo root)

```yaml
version: '3.8'
services:
  proxy:
    build:
      context: .
      dockerfile: nginx/Dockerfile
    ports:
      - "80:80"
    depends_on:
      - service-a
      - service-b

  service-a:
    build: ./service-a
    ports:
      - "3001:3001"

  service-b:
    build: ./service-b
    ports:
      - "3002:3002"
```

**`nginx/Dockerfile`**

```dockerfile
# Build frontend
FROM node:18-alpine as builder
WORKDIR /app/frontend
COPY frontend/package*.json ./
COPY frontend/ ./
RUN npm ci && npm run build

# Nginx image with built static files + proxy configuration
FROM nginx:stable-alpine
COPY --from=builder /app/frontend/build /usr/share/nginx/html
COPY nginx/nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

**`nginx/nginx.conf`**

```nginx
server {
    listen 80;
    server_name _;

    root /usr/share/nginx/html;
    index index.html;

    # proxy /api/service-a -> service-a:3001
    location /api/service-a/ {
        proxy_pass http://service-a:3001/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # proxy /api/service-b -> service-b:3002
    location /api/service-b/ {
        proxy_pass http://service-b:3002/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # fallthrough to index.html for SPA
    location / {
        try_files $uri /index.html;
    }
}
```

**`service-a/index.js`**

```js
const express = require('express');
const app = express();
const port = 3001;

app.get('/api/service-a', (req, res) => {
  res.json({ service: 'A', ts: new Date().toISOString() });
});

app.listen(port, () => console.log(`service-a listening on ${port}`));
```

**`service-a/package.json`**

```json
{
  "name": "service-a",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": { "start": "node index.js" },
  "dependencies": { "express": "^4.18.2" }
}
```

**`service-a/Dockerfile`**

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
EXPOSE 3001
CMD ["node", "index.js"]
```

`service-b` is identical except uses port **3002** and returns `{ service: 'B' }`.

---

## React sample (frontend)

**`frontend/src/App.js`**

```jsx
import React, {useEffect, useState} from 'react';

function App(){
  const [a, setA] = useState(null);
  const [b, setB] = useState(null);

  useEffect(()=>{
    fetch('/api/service-a')
      .then(r=>r.json())
      .then(setA)
      .catch(()=>setA({error:true}));

    fetch('/api/service-b')
      .then(r=>r.json())
      .then(setB)
      .catch(()=>setB({error:true}));
  },[]);

  return (
    <div style={{fontFamily:'Arial',padding:20}}>
      <h1>Demo React App (served by nginx)</h1>
      <h2>Service A</h2>
      <pre>{JSON.stringify(a, null, 2)}</pre>
      <h2>Service B</h2>
      <pre>{JSON.stringify(b, null, 2)}</pre>
    </div>
  )
}

export default App;
```

`frontend/package.json` should include `"build": "react-scripts build"` (if you use CRA) or an equivalent build step.

---

## How to deploy (steps)

1. **Prerequisites**

   * AWS account and credentials configured (AWS CLI or environment variables).
   * Terraform installed (v1.0+ recommended).
   * A public git repo with the code above, or copy the repo contents onto the EC2 after creation.
   * An SSH keypair: public key path (used by Terraform). You can also create with `ssh-keygen`.

2. **Place the files**

   * Put the repo root somewhere accessible. The Terraform expects `git_repo` variable to point to a public https Git repo containing the docker-compose + `nginx/`, `service-a/`, `service-b/`, `frontend/` directories.

3. **Configure Terraform variables**

   * Edit `terraform/variables.tf` defaults or create `terraform/terraform.tfvars` with your settings, e.g.:

     ```hcl
     aws_region = "us-east-1"
     key_name = "my-key"
     public_key_path = "~/.ssh/id_rsa.pub"
     git_repo = "https://github.com/you/your-demo-repo.git"
     my_ip_cidr = "203.0.113.5/32" # restrict SSH
     ```

4. **Run Terraform**

   ```bash
   cd terraform
   terraform init
   terraform plan -out plan.tfplan
   terraform apply "plan.tfplan"
   ```

   After apply, Terraform outputs `instance_public_ip`.

5. **Verify the app**

   * Open `http://<instance_public_ip>/` in your browser. NGINX will serve the built React app and proxy `/api/service-*` to the microservices.
   * If the instance had no git repo configured in `git_repo`, you can `scp` or `git push` the app to the instance and `docker-compose up -d --build` there.

6. **SSH access** (if you need to debug)

   ```bash
   ssh -i ~/.ssh/id_rsa ubuntu@<instance_public_ip>
   docker ps
   docker-compose logs -f
   ```

7. **Cleanup**

   ```bash
   cd terraform
   terraform destroy
   ```

---

## Security & production notes

* **Do not** leave `my_ip_cidr` as `0.0.0.0/0` for SSH — restrict to your IP.
* For production, prefer: ALB/ALB target groups + ECS/EKS or multiple EC2s behind an ALB.
* Use ACM for TLS and forward TLS at the ALB rather than managing certs inside containers.
* Store secrets (DB passwords, API keys) in AWS Secrets Manager or Parameter Store; **do not** bake into images.
* Use an IAM role for the instance (if you need S3/ECR access) instead of embedding credentials.
* Use logging & monitoring (CloudWatch, ELK, Prometheus/Grafana).

---

## Next steps / improvements

* Move containers to ECS Fargate and push images to ECR; use CloudFormation/Terraform for an ECS service + ALB.
* Add HTTPS via ACM and an ALB.
* Add CI/CD (GitHub Actions, CodePipeline) to build/push images and update the cluster.

---

If you want, I can:

* generate a full repo archive in this document you can `git init` and push to GitHub;
* or produce a ready-to-run `terraform.tfvars` and sample commands tailored to your AWS region and IP.

---

*End of document.*
